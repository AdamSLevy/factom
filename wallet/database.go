// Copyright 2016 Factom Foundation
// Use of this source code is governed by the MIT
// license that can be found in the LICENSE file.

package wallet

import (
	"fmt"
	"sync"

	"github.com/FactomProject/factom"
	"github.com/FactomProject/factomd/common/factoid"
)

// Wallet is a connection to a Factom Wallet Database
type Wallet struct {
	*WalletDatabaseOverlay
	transactions TxMap
	txdb         *TXDatabaseOverlay
}

type TxMap struct {
	m            sync.RWMutex
	transactions map[string]*factoid.Transaction
}

func (t *TxMap) GetAllTransactions() map[string]*factoid.Transaction {
	t.m.RLock()
	defer t.m.RUnlock()
	answer := map[string]*factoid.Transaction{}
	for k, v := range t.transactions {
		answer[k] = v
	}
	return answer
}

func (t *TxMap) Init() {
	t.m.Lock()
	defer t.m.Unlock()
	t.transactions = make(map[string]*factoid.Transaction)
}

func (t *TxMap) DoesTransactionExist(name string) bool {
	t.m.RLock()
	defer t.m.RUnlock()
	_, ok := t.transactions[name]
	return ok
}

func (t *TxMap) GetTransaction(name string) *factoid.Transaction {
	t.m.RLock()
	defer t.m.RUnlock()
	return t.transactions[name]
}

func (t *TxMap) SetTransaction(name string, tx *factoid.Transaction) {
	t.m.Lock()
	defer t.m.Unlock()
	t.transactions[name] = tx
}

func (t *TxMap) Delete(name string) {
	t.m.Lock()
	defer t.m.Unlock()
	delete(t.transactions, name)
}

func (t *TxMap) Len() int {
	t.m.RLock()
	defer t.m.RUnlock()
	return len(t.transactions)
}

func (w *Wallet) InitWallet() error {
	dbSeed, err := w.GetOrCreateDBSeed()
	if err != nil {
		return err
	}
	if dbSeed == nil {
		return fmt.Errorf("dbSeed not present in DB")
	}
	return nil
}

func NewOrOpenLevelDBWallet(path string) (*Wallet, error) {
	w := new(Wallet)
	w.transactions.Init()
	db, err := NewLevelDB(path)
	if err != nil {
		return nil, err
	}
	w.WalletDatabaseOverlay = db
	err = w.InitWallet()
	if err != nil {
		return nil, err
	}
	return w, nil
}

func NewOrOpenBoltDBWallet(path string) (*Wallet, error) {
	w := new(Wallet)
	w.transactions.Init()
	db, err := NewBoltDB(path)
	if err != nil {
		return nil, err
	}
	w.WalletDatabaseOverlay = db
	err = w.InitWallet()
	if err != nil {
		return nil, err
	}
	return w, nil
}

func NewMapDBWallet() (*Wallet, error) {
	w := new(Wallet)
	w.transactions.Init()
	db := NewMapDB()
	w.WalletDatabaseOverlay = db
	err := w.InitWallet()
	if err != nil {
		return nil, err
	}
	return w, nil
}

// Close closes a Factom Wallet Database
func (w *Wallet) Close() error {
	return w.DBO.Close()
}

// AddTXDB allows the wallet api to read from a local transaction cashe.
func (w *Wallet) AddTXDB(t *TXDatabaseOverlay) {
	w.txdb = t
}

func (w *Wallet) TXDB() *TXDatabaseOverlay {
	return w.txdb
}

// GenerateECAddress creates and stores a new Entry Credit Address in the
// Wallet. The address can be reproduced in the future using the Wallet Seed.
func (w *Wallet) GenerateECAddress() (*factom.ECAddress, error) {
	return w.GetNextECAddress()
}

// GenerateFCTAddress creates and stores a new Factoid Address in the Wallet.
// The address can be reproduced in the future using the Wallet Seed.
func (w *Wallet) GenerateFCTAddress() (*factom.FactoidAddress, error) {
	return w.GetNextFCTAddress()
}

// GetAllAddresses retrieves all Entry Credit and Factoid Addresses from the
// Wallet Database.
func (w *Wallet) GetAllAddresses() ([]*factom.FactoidAddress, []*factom.ECAddress, error) {
	fcs, err := w.GetAllFCTAddresses()
	if err != nil {
		return nil, nil, err
	}
	ecs, err := w.GetAllECAddresses()
	if err != nil {
		return nil, nil, err
	}

	return fcs, ecs, nil
}

// GetSeed returns the string representaion of the Wallet Seed. The Wallet Seed
// can be used to regenerate the Factoid and Entry Credit Addresses previously
// generated by the wallet. Note that Addresses that are imported into the
// Wallet cannot be regenerated using the Wallet Seed.
func (w *Wallet) GetSeed() (string, error) {
	seed, err := w.GetDBSeed()
	if err != nil {
		return "", err
	}

	return seed.MnemonicSeed, nil
}

func (w *Wallet) GetVersion() string {
	return Version
}

func (w *Wallet) GetApiVersion() string {
	return ApiVersion
}
